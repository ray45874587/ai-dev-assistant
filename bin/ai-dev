#!/usr/bin/env node

/**
 * AI开发辅助系统 - 命令行界面 v1.2.0
 * AI Development Assistant - Command Line Interface
 * 优化精简版
 */

const fs = require('fs');
const path = require('path');
const AIDevAssistant = require('../src/ai-dev-assistant');

// 颜色定义
const colors = {
    reset: '\x1b[0m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

class AIDevCLI {
    constructor() {
        const workingDir = process.cwd();
        this.assistant = new AIDevAssistant(workingDir);
        this.commands = {
            'init': this.initCommand.bind(this),
            'status': this.statusCommand.bind(this),
            'analyze': this.analyzeCommand.bind(this),
            'docs': this.docsCommand.bind(this),
            'clean': this.cleanCommand.bind(this),
            'help': this.helpCommand.bind(this),
            '--version': this.versionCommand.bind(this),
            '-v': this.versionCommand.bind(this)
        };
    }

    // 颜色输出方法
    print(message, color = 'reset') {
        console.log(`${colors[color]}${message}${colors.reset}`);
    }

    success(message) { this.print(`✅ ${message}`, 'green'); }
    error(message) { this.print(`❌ ${message}`, 'red'); }
    warning(message) { this.print(`⚠️ ${message}`, 'yellow'); }
    info(message) { this.print(`ℹ️ ${message}`, 'blue'); }

    async run() {
        try {
            const args = process.argv.slice(2);
            const command = args[0];
            const params = args.slice(1);

            if (!command) {
                this.showBanner();
                return;
            }

            if (this.commands[command]) {
                await this.commands[command](params);
            } else {
                this.error(`未知命令: ${command}`);
                this.info('使用 "ai-dev help" 查看可用命令');
                process.exit(1);
            }
        } catch (error) {
            this.error(`执行失败: ${error.message}`);
            process.exit(1);
        }
    }

    showBanner() {
        console.log('════════════════════════════════════════════════════════');
        this.print('    🤖 AI开发辅助系统 (AI Development Assistant)', 'cyan');
        this.print('    Version: 1.2.0', 'cyan');
        console.log('════════════════════════════════════════════════════════');
    }

    // 命令实现
    async initCommand(params) {
        this.info('初始化AI开发辅助系统...');
        try {
            const healthCheck = await this.assistant.healthCheck();
            if (healthCheck.healthy) {
                this.success('系统初始化成功');
                console.log(`当前工作目录: ${process.cwd()}`);
                console.log(`系统版本: ${healthCheck.version}`);
            } else {
                this.error('系统初始化失败');
                console.log('健康检查结果:', healthCheck.checks);
            }
        } catch (error) {
            this.error(`初始化失败: ${error.message}`);
        }
    }

    async statusCommand(params) {
        this.info('检查系统状态...');
        try {
            const overview = await this.assistant.getProjectOverview();
            if (overview) {
                console.log('');
                this.print('📊 项目状态', 'cyan');
                console.log(`项目名称: ${overview.name}`);
                console.log(`项目类型: ${overview.type}`);
                console.log(`主要语言: ${overview.language}`);
                console.log(`质量评分: ${overview.quality.score}/100 (${overview.quality.level})`);
                console.log(`文件数量: ${overview.metrics.files}`);
                console.log(`代码行数: ${overview.metrics.lines.toLocaleString()}`);
                
                if (overview.aiInsights.length > 0) {
                    console.log('');
                    this.print('🤖 AI洞察:', 'blue');
                    overview.aiInsights.forEach(insight => {
                        console.log(`  • ${insight}`);
                    });
                }
            } else {
                this.warning('未找到项目分析数据，请先运行 "ai-dev analyze"');
            }
        } catch (error) {
            this.error(`状态检查失败: ${error.message}`);
        }
    }

    async analyzeCommand(params) {
        const filePath = params[0];
        const saveFlag = params.includes('--save') || params.includes('-s');
        
        if (filePath && !filePath.startsWith('--')) {
            this.info(`分析文件: ${filePath}${saveFlag ? ' (保存报告)' : ''}`);
            try {
                const result = await this.assistant.analyzeFile(filePath, saveFlag);
                
                console.log('');
                this.print('📄 文件分析完成', 'green');
                console.log('');
                
                // 基本信息
                this.print('📋 文件信息:', 'blue');
                console.log(`  文件名: ${result.fileInfo.name}`);
                console.log(`  文件类型: ${result.intelligentType?.primaryType || '未知'}`);
                console.log(`  文件大小: ${(result.fileInfo.size / 1024).toFixed(2)} KB`);
                console.log(`  代码行数: ${result.fileInfo.lines}`);
                console.log(`  最后修改: ${result.fileInfo.lastModified.toLocaleDateString()}`);
                
                // 质量分析
                console.log('');
                this.print('📊 质量分析:', 'blue');
                console.log(`  质量评分: ${result.quality.score}/100 (${result.quality.level})`);
                console.log(`  代码行数: ${result.quality.metrics?.codeLines || 0}`);
                console.log(`  注释行数: ${result.quality.metrics?.commentLines || 0}`);
                console.log(`  注释比例: ${((result.quality.metrics?.commentRatio || 0) * 100).toFixed(1)}%`);
                
                // 复杂度分析
                console.log('');
                this.print('🔍 复杂度分析:', 'blue');
                console.log(`  圈复杂度: ${result.complexity.cyclomaticComplexity} (${result.complexity.maintainabilityLevel || 'unknown'})`);
                console.log(`  函数数量: ${result.complexity.functionCount || 'unknown'}`);
                console.log(`  最大嵌套深度: ${result.complexity.maxNestingDepth || 'unknown'}`);
                
                // 安全性分析
                console.log('');
                this.print('🛡️ 安全性分析:', 'blue');
                console.log(`  风险级别: ${result.security.riskLevel}`);
                console.log(`  安全问题: ${result.security.totalIssues} 个`);
                
                if (result.security.vulnerabilities && result.security.vulnerabilities.length > 0) {
                    console.log('');
                    this.print('🚨 安全问题:', 'red');
                    result.security.vulnerabilities.forEach((vuln, i) => {
                        console.log(`  ${i + 1}. ${vuln.type}: ${vuln.description}`);
                    });
                }
                
                if (result.security.warnings && result.security.warnings.length > 0) {
                    console.log('');
                    this.print('⚠️ 安全警告:', 'yellow');
                    result.security.warnings.forEach((warning, i) => {
                        console.log(`  ${i + 1}. ${warning.type}: ${warning.description}`);
                    });
                }
                
                // AI建议
                if (result.improvements && result.improvements.immediate && result.improvements.immediate.length > 0) {
                    console.log('');
                    this.print('💡 AI建议:', 'cyan');
                    result.improvements.immediate.forEach((suggestion, i) => {
                        console.log(`  ${i + 1}. ${suggestion.action}`);
                    });
                }
                
                // 如果保存了报告，显示路径
                if (result.reportPath) {
                    console.log('');
                    this.print('📄 分析报告已保存:', 'green');
                    console.log(`  ${path.basename(result.reportPath)}`);
                    console.log(`  位置: AI助手文档/`);
                }
                
            } catch (error) {
                this.error(`文件分析失败: ${error.message}`);
            }
            return;
        } else {
            this.info('正在进行AI智能分析...');
        }
        
        try {
            const result = await this.assistant.analyze();
            
            console.log('');
            this.print('📊 项目分析完成', 'green');
            console.log('');
            
            this.print('📋 基本信息:', 'blue');
            console.log(`  项目名称: ${result.metadata.name}`);
            console.log(`  项目类型: ${result.project.type}`);
            console.log(`  主要语言: ${result.project.language}`);
            console.log(`  技术框架: ${result.project.framework.join(', ') || '未检测到'}`);
            console.log('');
            
            this.print('📊 代码指标:', 'blue');
            console.log(`  文件总数: ${result.codeMetrics.totalFiles}`);
            console.log(`  代码行数: ${result.codeMetrics.totalLines.toLocaleString()}`);
            console.log(`  复杂度: ${result.codeMetrics.complexity}`);
            console.log('');
            
            this.print('🎯 质量评估:', 'blue');
            console.log(`  质量评分: ${result.quality.score}/100`);
            if (result.quality.suggestions.length > 0) {
                console.log('  改进建议:');
                result.quality.suggestions.slice(0, 3).forEach((suggestion, i) => {
                    console.log(`    ${i + 1}. ${suggestion}`);
                });
            }
            
            console.log('');
            this.success('分析完成！使用 "ai-dev docs" 生成详细文档');
            
        } catch (error) {
            this.error(`分析失败: ${error.message}`);
        }
    }

    async docsCommand(params) {
        this.info('正在智能生成项目文档...');
        try {
            const result = await this.assistant.generateDocs();
            
            if (result.success) {
                this.success(`文档生成成功！已生成 ${result.files.length} 个文档`);
                console.log('');
                console.log('生成的文档:');
                result.files.forEach(file => {
                    console.log(`  📄 ${file}`);
                });
                console.log('');
                console.log(`文档位置: ${result.docsDirectory}/`);
            } else {
                this.error('文档生成失败');
                if (result.error) {
                    console.log(`错误: ${result.error}`);
                }
            }
        } catch (error) {
            this.error(`文档生成失败: ${error.message}`);
        }
    }

    async cleanCommand(params) {
        this.info('清理系统文件...');
        try {
            const result = await this.assistant.cleanup();
            if (result) {
                this.success('清理完成');
            } else {
                this.warning('清理过程中出现问题');
            }
        } catch (error) {
            this.error(`清理失败: ${error.message}`);
        }
    }

    versionCommand(params) {
        console.log('1.2.0');
    }

    helpCommand(params) {
        this.showBanner();
        console.log('🤖 AI开发辅助系统 - 命令行工具');
        console.log('');
        console.log('使用方法:');
        console.log('  ai-dev <command> [options]');
        console.log('');
        console.log('命令:');
        console.log('  init                    初始化AI开发辅助系统');
        console.log('  status                  查看项目状态');
        console.log('  analyze [file]          智能项目分析或单文件分析');
        console.log('  docs                    智能生成项目文档');
        console.log('  clean                   清理系统文件');
        console.log('  help                    显示帮助信息');
        console.log('  --version/-v            显示版本号');
        console.log('');
        console.log('单文件分析选项:');
        console.log('  --save, -s              保存分析报告到AI助手文档目录');
        console.log('');
        console.log('示例:');
        console.log('  ai-dev init                      # 初始化系统');
        console.log('  ai-dev analyze                   # 智能分析整个项目');
        console.log('  ai-dev analyze index.php         # 分析单个文件');
        console.log('  ai-dev analyze index.php --save  # 分析文件并保存报告');
        console.log('  ai-dev docs                      # 生成智能文档');
        console.log('  ai-dev status                    # 查看项目状态');
        console.log('');
        console.log('更多信息:');
        console.log('  文档: ./AI助手文档/');
    }
}

// 运行CLI
const cli = new AIDevCLI();
cli.run().catch(error => {
    console.error('❌ 系统错误:', error.message);
    process.exit(1);
});
