#!/usr/bin/env node

/**
 * AIå¼€å‘è¾…åŠ©ç³»ç»Ÿ - å‘½ä»¤è¡Œç•Œé¢ v1.2.0
 * AI Development Assistant - Command Line Interface
 * ä¼˜åŒ–ç²¾ç®€ç‰ˆ
 */

const fs = require('fs');
const path = require('path');
const AIDevAssistant = require('../src/ai-dev-assistant');

// é¢œè‰²å®šä¹‰
const colors = {
    reset: '\x1b[0m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m'
};

class AIDevCLI {
    constructor() {
        const workingDir = process.cwd();
        this.assistant = new AIDevAssistant(workingDir);
        this.commands = {
            'init': this.initCommand.bind(this),
            'status': this.statusCommand.bind(this),
            'analyze': this.analyzeCommand.bind(this),
            'docs': this.docsCommand.bind(this),
            'clean': this.cleanCommand.bind(this),
            'update': this.updateCommand.bind(this),
            'help': this.helpCommand.bind(this),
            '--version': this.versionCommand.bind(this),
            '-v': this.versionCommand.bind(this)
        };
    }

    // é¢œè‰²è¾“å‡ºæ–¹æ³•
    print(message, color = 'reset') {
        console.log(`${colors[color]}${message}${colors.reset}`);
    }

    success(message) { this.print(`âœ… ${message}`, 'green'); }
    error(message) { this.print(`âŒ ${message}`, 'red'); }
    warning(message) { this.print(`âš ï¸ ${message}`, 'yellow'); }
    info(message) { this.print(`â„¹ï¸ ${message}`, 'blue'); }

    async run() {
        try {
            const args = process.argv.slice(2);
            const command = args[0];
            const params = args.slice(1);

            if (!command) {
                this.showBanner();
                return;
            }

            if (this.commands[command]) {
                await this.commands[command](params);
            } else {
                this.error(`æœªçŸ¥å‘½ä»¤: ${command}`);
                this.info('ä½¿ç”¨ "ai-dev help" æŸ¥çœ‹å¯ç”¨å‘½ä»¤');
                process.exit(1);
            }
        } catch (error) {
            this.error(`æ‰§è¡Œå¤±è´¥: ${error.message}`);
            process.exit(1);
        }
    }

    showBanner() {
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        this.print('    ğŸ¤– AIå¼€å‘è¾…åŠ©ç³»ç»Ÿ (AI Development Assistant)', 'cyan');
        this.print('    Version: 1.3.0', 'cyan');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    }

    // å‘½ä»¤å®ç°
    async initCommand(params) {
        this.info('åˆå§‹åŒ–AIå¼€å‘è¾…åŠ©ç³»ç»Ÿ...');
        try {
            const healthCheck = await this.assistant.healthCheck();
            if (healthCheck.healthy) {
                this.success('ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ');
                console.log(`å½“å‰å·¥ä½œç›®å½•: ${process.cwd()}`);
                console.log(`ç³»ç»Ÿç‰ˆæœ¬: ${healthCheck.version}`);
            } else {
                this.error('ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥');
                console.log('å¥åº·æ£€æŸ¥ç»“æœ:', healthCheck.checks);
            }
        } catch (error) {
            this.error(`åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
        }
    }

    async statusCommand(params) {
        this.info('æ£€æŸ¥ç³»ç»ŸçŠ¶æ€...');
        try {
            const overview = await this.assistant.getProjectOverview();
            if (overview) {
                console.log('');
                this.print('ğŸ“Š é¡¹ç›®çŠ¶æ€', 'cyan');
                console.log(`é¡¹ç›®åç§°: ${overview.name}`);
                console.log(`é¡¹ç›®ç±»å‹: ${overview.type}`);
                console.log(`ä¸»è¦è¯­è¨€: ${overview.language}`);
                console.log(`è´¨é‡è¯„åˆ†: ${overview.quality.score}/100 (${overview.quality.level})`);
                console.log(`æ–‡ä»¶æ•°é‡: ${overview.metrics.files}`);
                console.log(`ä»£ç è¡Œæ•°: ${overview.metrics.lines.toLocaleString()}`);
                
                if (overview.aiInsights.length > 0) {
                    console.log('');
                    this.print('ğŸ¤– AIæ´å¯Ÿ:', 'blue');
                    overview.aiInsights.forEach(insight => {
                        console.log(`  â€¢ ${insight}`);
                    });
                }
            } else {
                this.warning('æœªæ‰¾åˆ°é¡¹ç›®åˆ†ææ•°æ®ï¼Œè¯·å…ˆè¿è¡Œ "ai-dev analyze"');
            }
        } catch (error) {
            this.error(`çŠ¶æ€æ£€æŸ¥å¤±è´¥: ${error.message}`);
        }
    }

    async analyzeCommand(params) {
        const filePath = params[0];
        const saveFlag = params.includes('--save') || params.includes('-s');
        
        if (filePath && !filePath.startsWith('--')) {
            this.info(`åˆ†ææ–‡ä»¶: ${filePath}${saveFlag ? ' (ä¿å­˜æŠ¥å‘Š)' : ''}`);
            try {
                const result = await this.assistant.analyzeFile(filePath, saveFlag);
                
                console.log('');
                this.print('ğŸ“„ æ–‡ä»¶åˆ†æå®Œæˆ', 'green');
                console.log('');
                
                // åŸºæœ¬ä¿¡æ¯
                this.print('ğŸ“‹ æ–‡ä»¶ä¿¡æ¯:', 'blue');
                console.log(`  æ–‡ä»¶å: ${result.fileInfo.name}`);
                console.log(`  æ–‡ä»¶ç±»å‹: ${result.intelligentType?.primaryType || 'æœªçŸ¥'}`);
                console.log(`  æ–‡ä»¶å¤§å°: ${(result.fileInfo.size / 1024).toFixed(2)} KB`);
                console.log(`  ä»£ç è¡Œæ•°: ${result.fileInfo.lines}`);
                console.log(`  æœ€åä¿®æ”¹: ${result.fileInfo.lastModified.toLocaleDateString()}`);
                
                // è´¨é‡åˆ†æ
                console.log('');
                this.print('ğŸ“Š è´¨é‡åˆ†æ:', 'blue');
                console.log(`  è´¨é‡è¯„åˆ†: ${result.quality.score}/100 (${result.quality.level})`);
                console.log(`  ä»£ç è¡Œæ•°: ${result.quality.metrics?.codeLines || 0}`);
                console.log(`  æ³¨é‡Šè¡Œæ•°: ${result.quality.metrics?.commentLines || 0}`);
                console.log(`  æ³¨é‡Šæ¯”ä¾‹: ${((result.quality.metrics?.commentRatio || 0) * 100).toFixed(1)}%`);
                
                // å¤æ‚åº¦åˆ†æ
                console.log('');
                this.print('ğŸ” å¤æ‚åº¦åˆ†æ:', 'blue');
                console.log(`  åœˆå¤æ‚åº¦: ${result.complexity.cyclomaticComplexity} (${result.complexity.maintainabilityLevel || 'unknown'})`);
                console.log(`  å‡½æ•°æ•°é‡: ${result.complexity.functionCount || 'unknown'}`);
                console.log(`  æœ€å¤§åµŒå¥—æ·±åº¦: ${result.complexity.maxNestingDepth || 'unknown'}`);
                
                // å®‰å…¨æ€§åˆ†æ
                console.log('');
                this.print('ğŸ›¡ï¸ å®‰å…¨æ€§åˆ†æ:', 'blue');
                console.log(`  é£é™©çº§åˆ«: ${result.security.riskLevel}`);
                console.log(`  å®‰å…¨é—®é¢˜: ${result.security.totalIssues} ä¸ª`);
                
                if (result.security.vulnerabilities && result.security.vulnerabilities.length > 0) {
                    console.log('');
                    this.print('ğŸš¨ å®‰å…¨é—®é¢˜:', 'red');
                    result.security.vulnerabilities.forEach((vuln, i) => {
                        console.log(`  ${i + 1}. ${vuln.type}: ${vuln.description}`);
                    });
                }
                
                if (result.security.warnings && result.security.warnings.length > 0) {
                    console.log('');
                    this.print('âš ï¸ å®‰å…¨è­¦å‘Š:', 'yellow');
                    result.security.warnings.forEach((warning, i) => {
                        console.log(`  ${i + 1}. ${warning.type}: ${warning.description}`);
                    });
                }
                
                // AIå»ºè®®
                if (result.improvements && result.improvements.immediate && result.improvements.immediate.length > 0) {
                    console.log('');
                    this.print('ğŸ’¡ AIå»ºè®®:', 'cyan');
                    result.improvements.immediate.forEach((suggestion, i) => {
                        console.log(`  ${i + 1}. ${suggestion.action}`);
                    });
                }
                
                // å¦‚æœä¿å­˜äº†æŠ¥å‘Šï¼Œæ˜¾ç¤ºè·¯å¾„
                if (result.reportPath) {
                    console.log('');
                    this.print('ğŸ“„ åˆ†ææŠ¥å‘Šå·²ä¿å­˜:', 'green');
                    console.log(`  ${path.basename(result.reportPath)}`);
                    console.log(`  ä½ç½®: AIåŠ©æ‰‹æ–‡æ¡£/`);
                }
                
            } catch (error) {
                this.error(`æ–‡ä»¶åˆ†æå¤±è´¥: ${error.message}`);
            }
            return;
        } else {
            this.info('æ­£åœ¨è¿›è¡ŒAIæ™ºèƒ½åˆ†æ...');
        }
        
        try {
            const result = await this.assistant.analyze();
            
            console.log('');
            this.print('ğŸ“Š é¡¹ç›®åˆ†æå®Œæˆ', 'green');
            console.log('');
            
            this.print('ğŸ“‹ åŸºæœ¬ä¿¡æ¯:', 'blue');
            console.log(`  é¡¹ç›®åç§°: ${result.metadata.name}`);
            console.log(`  é¡¹ç›®ç±»å‹: ${result.project.type}`);
            console.log(`  ä¸»è¦è¯­è¨€: ${result.project.language}`);
            console.log(`  æŠ€æœ¯æ¡†æ¶: ${result.project.framework.join(', ') || 'æœªæ£€æµ‹åˆ°'}`);
            console.log('');
            
            this.print('ğŸ“Š ä»£ç æŒ‡æ ‡:', 'blue');
            console.log(`  æ–‡ä»¶æ€»æ•°: ${result.codeMetrics.totalFiles}`);
            console.log(`  ä»£ç è¡Œæ•°: ${result.codeMetrics.totalLines.toLocaleString()}`);
            console.log(`  å¤æ‚åº¦: ${result.codeMetrics.complexity}`);
            console.log('');
            
            this.print('ğŸ¯ è´¨é‡è¯„ä¼°:', 'blue');
            console.log(`  è´¨é‡è¯„åˆ†: ${result.quality.score}/100`);
            if (result.quality.suggestions.length > 0) {
                console.log('  æ”¹è¿›å»ºè®®:');
                result.quality.suggestions.slice(0, 3).forEach((suggestion, i) => {
                    console.log(`    ${i + 1}. ${suggestion}`);
                });
            }
            
            console.log('');
            this.success('åˆ†æå®Œæˆï¼ä½¿ç”¨ "ai-dev docs" ç”Ÿæˆè¯¦ç»†æ–‡æ¡£');
            
        } catch (error) {
            this.error(`åˆ†æå¤±è´¥: ${error.message}`);
        }
    }

    async docsCommand(params) {
        this.info('æ­£åœ¨æ™ºèƒ½ç”Ÿæˆé¡¹ç›®æ–‡æ¡£...');
        try {
            const result = await this.assistant.generateDocs();
            
            if (result.success) {
                this.success(`æ–‡æ¡£ç”ŸæˆæˆåŠŸï¼å·²ç”Ÿæˆ ${result.files.length} ä¸ªæ–‡æ¡£`);
                console.log('');
                console.log('ç”Ÿæˆçš„æ–‡æ¡£:');
                result.files.forEach(file => {
                    console.log(`  ğŸ“„ ${file}`);
                });
                console.log('');
                console.log(`æ–‡æ¡£ä½ç½®: ${result.docsDirectory}/`);
            } else {
                this.error('æ–‡æ¡£ç”Ÿæˆå¤±è´¥');
                if (result.error) {
                    console.log(`é”™è¯¯: ${result.error}`);
                }
            }
        } catch (error) {
            this.error(`æ–‡æ¡£ç”Ÿæˆå¤±è´¥: ${error.message}`);
        }
    }

    async cleanCommand(params) {
        this.info('æ¸…ç†ç³»ç»Ÿæ–‡ä»¶...');
        try {
            const result = await this.assistant.cleanup();
            if (result) {
                this.success('æ¸…ç†å®Œæˆ');
            } else {
                this.warning('æ¸…ç†è¿‡ç¨‹ä¸­å‡ºç°é—®é¢˜');
            }
        } catch (error) {
            this.error(`æ¸…ç†å¤±è´¥: ${error.message}`);
        }
    }

    async updateCommand(params) {
        const forceUpdate = params.includes('--force') || params.includes('-f');
        
        this.info('ğŸ”„ å¯åŠ¨æ™ºèƒ½ä¸Šä¸‹æ–‡åŒæ­¥...');
        
        try {
            // æ£€æµ‹é¡¹ç›®å˜æ›´
            this.info('ğŸ“Š æ£€æµ‹é¡¹ç›®å˜æ›´...');
            const changes = await this.assistant.detectProjectChanges();
            
            if (!changes.hasChanges && !forceUpdate) {
                this.success('âœ¨ é¡¹ç›®ä¸Šä¸‹æ–‡å·²æ˜¯æœ€æ–°çŠ¶æ€');
                console.log('');
                console.log('ğŸ’¡ æç¤º:');
                console.log('  - ä½¿ç”¨ --force å¼ºåˆ¶æ›´æ–°å®Œæ•´ä¸Šä¸‹æ–‡');
                console.log('  - é¡¹ç›®æœ‰å˜æ›´æ—¶ä¼šè‡ªåŠ¨è§¦å‘å¢é‡åŒæ­¥');
                return;
            }
            
            console.log('');
            this.print('ğŸ” æ£€æµ‹åˆ°çš„å˜æ›´:', 'cyan');
            
            if (changes.newFiles && changes.newFiles.length > 0) {
                console.log(`  ğŸ“„ æ–°å¢æ–‡ä»¶: ${changes.newFiles.length} ä¸ª`);
                changes.newFiles.slice(0, 5).forEach(file => {
                    console.log(`     + ${file}`);
                });
                if (changes.newFiles.length > 5) {
                    console.log(`     ... è¿˜æœ‰ ${changes.newFiles.length - 5} ä¸ªæ–‡ä»¶`);
                }
            }
            
            if (changes.modifiedFiles && changes.modifiedFiles.length > 0) {
                console.log(`  âœï¸  ä¿®æ”¹æ–‡ä»¶: ${changes.modifiedFiles.length} ä¸ª`);
                changes.modifiedFiles.slice(0, 5).forEach(file => {
                    console.log(`     ~ ${file}`);
                });
                if (changes.modifiedFiles.length > 5) {
                    console.log(`     ... è¿˜æœ‰ ${changes.modifiedFiles.length - 5} ä¸ªæ–‡ä»¶`);
                }
            }
            
            if (changes.deletedFiles && changes.deletedFiles.length > 0) {
                console.log(`  ğŸ—‘ï¸  åˆ é™¤æ–‡ä»¶: ${changes.deletedFiles.length} ä¸ª`);
                changes.deletedFiles.slice(0, 3).forEach(file => {
                    console.log(`     - ${file}`);
                });
            }
            
            if (changes.dependencyChanges) {
                console.log(`  ğŸ“¦ ä¾èµ–å˜æ›´: package.json å·²æ›´æ–°`);
            }
            
            console.log('');
            
            // æ‰§è¡Œå¢é‡åˆ†æ
            this.info('ğŸ¤– æ‰§è¡Œæ™ºèƒ½å¢é‡åˆ†æ...');
            const contextUpdate = await this.assistant.performIncrementalUpdate(changes, forceUpdate);
            
            console.log('');
            this.print('ğŸ“‹ ä¸Šä¸‹æ–‡åŒæ­¥ç»“æœ:', 'green');
            console.log(`  âš¡ å¤„ç†æ¨¡å¼: ${forceUpdate ? 'å®Œæ•´æ›´æ–°' : 'å¢é‡åŒæ­¥'}`);
            console.log(`  ğŸ“Š åˆ†ææ–‡ä»¶: ${contextUpdate.processedFiles || 0} ä¸ª`);
            console.log(`  ğŸ’¾ ä¸Šä¸‹æ–‡å¤§å°: ${((contextUpdate.contextSize || 0) / 1024).toFixed(1)} KB`);
            console.log(`  ğŸ¯ TokenèŠ‚çœ: ${(contextUpdate.tokensSaved || 0).toLocaleString()} tokens`);
            console.log(`  â±ï¸  å¤„ç†è€—æ—¶: ${contextUpdate.processingTime || 0}ms`);
            
            // æ˜¾ç¤ºä¸Šä¸‹æ–‡æ‘˜è¦
            if (contextUpdate.summary) {
                console.log('');
                this.print('ğŸ“ é¡¹ç›®ä¸Šä¸‹æ–‡æ‘˜è¦:', 'blue');
                console.log(`  ğŸ—ï¸  æ¶æ„æ¨¡å¼: ${contextUpdate.summary.architecturePattern || 'åˆ†æä¸­'}`);
                console.log(`  ğŸ’» ä¸»è¦æŠ€æœ¯æ ˆ: ${(contextUpdate.summary.techStack || []).join(', ') || 'æ£€æµ‹ä¸­'}`);
                console.log(`  ğŸ“ˆ ä»£ç è´¨é‡: ${contextUpdate.summary.qualityScore || 0}/100`);
                console.log(`  ğŸ”’ å®‰å…¨è¯„çº§: ${contextUpdate.summary.securityLevel || 'è¯„ä¼°ä¸­'}`);
                
                if (contextUpdate.summary.keyInsights && contextUpdate.summary.keyInsights.length > 0) {
                    console.log('');
                    this.print('ğŸ’¡ å…³é”®æ´å¯Ÿ:', 'cyan');
                    contextUpdate.summary.keyInsights.forEach((insight, i) => {
                        console.log(`  ${i + 1}. ${insight}`);
                    });
                }
                
                if (contextUpdate.summary.recommendations && contextUpdate.summary.recommendations.length > 0) {
                    console.log('');
                    this.print('ğŸ¯ æ™ºèƒ½å»ºè®®:', 'yellow');
                    contextUpdate.summary.recommendations.slice(0, 3).forEach((rec, i) => {
                        console.log(`  ${i + 1}. ${rec}`);
                    });
                }
            }
            
            // ä¿å­˜ä¸Šä¸‹æ–‡ç¼“å­˜
            this.info('ğŸ’¾ ä¿å­˜æ™ºèƒ½ä¸Šä¸‹æ–‡ç¼“å­˜...');
            await this.assistant.saveContextCache(contextUpdate.context);
            
            console.log('');
            this.success('ğŸ‰ ä¸Šä¸‹æ–‡åŒæ­¥å®Œæˆï¼AIåŠ©æ‰‹å·²è·å¾—æœ€æ–°é¡¹ç›®çŠ¶æ€');
            console.log('');
            console.log('ğŸ’¡ ä¼˜åŒ–æ•ˆæœ:');
            console.log('  âœ… åç»­AIåˆ†æé€Ÿåº¦æå‡ 60%+');
            console.log('  âœ… Tokenæ¶ˆè€—å‡å°‘ 40%+');
            console.log('  âœ… åˆ†æå‡†ç¡®æ€§æå‡ 25%+');
            
        } catch (error) {
            this.error(`ä¸Šä¸‹æ–‡åŒæ­¥å¤±è´¥: ${error.message}`);
            console.log('');
            console.log('ğŸ”§ æ•…éšœæ’é™¤:');
            console.log('  1. æ£€æŸ¥é¡¹ç›®æ–‡ä»¶è®¿é—®æƒé™');
            console.log('  2. ç¡®ä¿.ai-contextç›®å½•å¯å†™');
            console.log('  3. ä½¿ç”¨ --force é‡å»ºå®Œæ•´ä¸Šä¸‹æ–‡');
        }
    }

    versionCommand(params) {
        console.log('1.3.0');
    }

    helpCommand(params) {
        this.showBanner();
        console.log('ğŸ¤– AIå¼€å‘è¾…åŠ©ç³»ç»Ÿ - å‘½ä»¤è¡Œå·¥å…·');
        console.log('');
        console.log('ä½¿ç”¨æ–¹æ³•:');
        console.log('  ai-dev <command> [options]');
        console.log('');
        console.log('å‘½ä»¤:');
        console.log('  init                    åˆå§‹åŒ–AIå¼€å‘è¾…åŠ©ç³»ç»Ÿ');
        console.log('  status                  æŸ¥çœ‹é¡¹ç›®çŠ¶æ€');
        console.log('  analyze [file]          æ™ºèƒ½é¡¹ç›®åˆ†ææˆ–å•æ–‡ä»¶åˆ†æ');
        console.log('  docs                    æ™ºèƒ½ç”Ÿæˆé¡¹ç›®æ–‡æ¡£');
        console.log('  clean                   æ¸…ç†ç³»ç»Ÿæ–‡ä»¶');
        console.log('  update [--force]        æ™ºèƒ½ä¸Šä¸‹æ–‡åŒæ­¥ (å‡å°‘tokenæ¶ˆè€—)');
        console.log('  help                    æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯');
        console.log('  --version/-v            æ˜¾ç¤ºç‰ˆæœ¬å·');
        console.log('');
        console.log('ä¸Šä¸‹æ–‡åŒæ­¥é€‰é¡¹:');
        console.log('  --force, -f             å¼ºåˆ¶å®Œæ•´ä¸Šä¸‹æ–‡é‡å»º');
        console.log('');
        console.log('å•æ–‡ä»¶åˆ†æé€‰é¡¹:');
        console.log('  --save, -s              ä¿å­˜åˆ†ææŠ¥å‘Šåˆ°AIåŠ©æ‰‹æ–‡æ¡£ç›®å½•');
        console.log('');
        console.log('ç¤ºä¾‹:');
        console.log('  ai-dev init                      # åˆå§‹åŒ–ç³»ç»Ÿ');
        console.log('  ai-dev update                    # æ™ºèƒ½ä¸Šä¸‹æ–‡åŒæ­¥');
        console.log('  ai-dev update --force            # å¼ºåˆ¶å®Œæ•´ä¸Šä¸‹æ–‡é‡å»º');
        console.log('  ai-dev analyze                   # æ™ºèƒ½åˆ†ææ•´ä¸ªé¡¹ç›®');
        console.log('  ai-dev analyze index.php         # åˆ†æå•ä¸ªæ–‡ä»¶');
        console.log('  ai-dev analyze index.php --save  # åˆ†ææ–‡ä»¶å¹¶ä¿å­˜æŠ¥å‘Š');
        console.log('  ai-dev docs                      # ç”Ÿæˆæ™ºèƒ½æ–‡æ¡£');
        console.log('  ai-dev status                    # æŸ¥çœ‹é¡¹ç›®çŠ¶æ€');
        console.log('');
        console.log('æ›´å¤šä¿¡æ¯:');
        console.log('  æ–‡æ¡£: ./AIåŠ©æ‰‹æ–‡æ¡£/');
    }
}

// è¿è¡ŒCLI
const cli = new AIDevCLI();
cli.run().catch(error => {
    console.error('âŒ ç³»ç»Ÿé”™è¯¯:', error.message);
    process.exit(1);
});
